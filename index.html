<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>3D –ó–µ–º–ª—è PRO + –°–∞–º–æ–ª—ë—Ç—ã + –û–ø–∞—Å–Ω—ã–µ –∑–æ–Ω—ã</title>

<style>
body{
  margin:0;
  overflow:hidden;
  background:#000;
  font-family:sans-serif;
}
#ui{
  position:absolute;
  top:10px;
  left:10px;
  background:rgba(0,0,0,0.7);
  padding:10px;
  border-radius:8px;
  color:#FFA500;
}
input,button{
  background:#111;
  color:#FFA500;
  border:1px solid #FFA500;
  padding:5px;
  margin:2px;
}
</style>
</head>
<body>

<div id="ui">
<input id="city" placeholder="–ì–æ—Ä–æ–¥">
<button onclick="searchCity()">–ü–æ–≥–æ–¥–∞</button>
<div id="weather"></div>
<hr>
üî¥ –í–æ–π–Ω–∞ &nbsp; üü† –®—Ç–æ—Ä–º—ã
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>

<script>
// ===== –°–¶–ï–ù–ê =====
const scene=new THREE.Scene();

const camera=new THREE.PerspectiveCamera(
60,window.innerWidth/window.innerHeight,0.1,1000
);
camera.position.z=3;

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===== –°–û–õ–ù–¶–ï =====
const sun=new THREE.DirectionalLight(0xffffff,1.5);
sun.position.set(5,0,5);
scene.add(sun);

// ===== –ó–ï–ú–õ–Ø =====
const geometry=new THREE.SphereGeometry(1,64,64);

const earth=new THREE.Mesh(
geometry,
new THREE.MeshPhongMaterial({
map:new THREE.TextureLoader().load(
"https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg"
)})
);
scene.add(earth);

// ===== –ù–û–ß–¨ =====
const night=new THREE.Mesh(
geometry,
new THREE.MeshBasicMaterial({
map:new THREE.TextureLoader().load(
"https://threejs.org/examples/textures/planets/earth_lights_2048.png"
),
transparent:true,
opacity:0.6,
blending:THREE.AdditiveBlending
})
);
scene.add(night);

// ===== –û–ë–õ–ê–ö–ê =====
const clouds=new THREE.Mesh(
new THREE.SphereGeometry(1.01,64,64),
new THREE.MeshLambertMaterial({
map:new THREE.TextureLoader().load(
"https://threejs.org/examples/textures/planets/earth_clouds_1024.png"
),
transparent:true,
opacity:0.4
})
);
scene.add(clouds);

// ===== –ú–ê–†–ö–ï–† =====
function addMarker(lat,lon,color=0xff0000){

const phi=(90-lat)*(Math.PI/180);
const theta=(lon+180)*(Math.PI/180);

const x=-Math.sin(phi)*Math.cos(theta);
const y=Math.cos(phi);
const z=Math.sin(phi)*Math.sin(theta);

const marker=new THREE.Mesh(
new THREE.SphereGeometry(0.02,16,16),
new THREE.MeshBasicMaterial({color})
);

marker.position.set(x,y,z);
earth.add(marker);
}

// ===== –û–ó–í–£–ß–ö–ê =====
function speak(text){
const u=new SpeechSynthesisUtterance(text);
u.lang="ru-RU";
speechSynthesis.cancel();
speechSynthesis.speak(u);
}

// ===== –ü–û–ì–û–î–ê –ì–û–†–û–î–ê =====
async function searchCity(){

const city=document.getElementById("city").value;
if(!city) return;

const geo=await fetch(
`https://geocoding-api.open-meteo.com/v1/search?name=${city}&count=1`
).then(r=>r.json());

if(!geo.results){
weather.innerText="–ì–æ—Ä–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω";
speak("–ì–æ—Ä–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω");
return;
}

const lat=geo.results[0].latitude;
const lon=geo.results[0].longitude;

addMarker(lat,lon);

const data=await fetch(
`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`
).then(r=>r.json());

const w=data.current_weather;

weather.innerText=
`${city}
–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: ${w.temperature}¬∞C
–í–µ—Ç–µ—Ä: ${w.windspeed} –∫–º/—á`;

speak(
`–ì–æ—Ä–æ–¥ ${city}.
–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ ${w.temperature} –≥—Ä–∞–¥—É—Å–æ–≤.
–í–µ—Ç–µ—Ä ${w.windspeed} –∫–∏–ª–æ–º–µ—Ç—Ä–æ–≤ –≤ —á–∞—Å.`
);
}

// ===== –ö–õ–ò–ö –ü–û –®–ê–†–£ =====
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();

window.addEventListener("click",(e)=>{

mouse.x=(e.clientX/window.innerWidth)*2-1;
mouse.y=-(e.clientY/window.innerHeight)*2+1;

raycaster.setFromCamera(mouse,camera);
const hit=raycaster.intersectObject(earth);

if(!hit.length) return;

const p=hit[0].point;

const lat=90-(Math.acos(p.y)*180/Math.PI);
const lon=((Math.atan2(p.z,p.x)*180/Math.PI)+180)%360-180;

addMarker(lat,lon,0x00ff00);
});

// ===== –°–ê–ú–û–õ–Å–¢–´ =====
let planes=[];

async function loadPlanes(){

planes.forEach(p=>earth.remove(p));
planes=[];

const data=await fetch(
"https://opensky-network.org/api/states/all"
).then(r=>r.json());

if(!data.states) return;

data.states.slice(0,200).forEach(s=>{

const lat=s[6];
const lon=s[5];
if(!lat||!lon) return;

const phi=(90-lat)*(Math.PI/180);
const theta=(lon+180)*(Math.PI/180);

const x=-Math.sin(phi)*Math.cos(theta);
const y=Math.cos(phi);
const z=Math.sin(phi)*Math.sin(theta);

const plane=new THREE.Mesh(
new THREE.SphereGeometry(0.01,8,8),
new THREE.MeshBasicMaterial({color:0xffff00})
);

plane.position.set(x*1.02,y*1.02,z*1.02);

earth.add(plane);
planes.push(plane);

});

}

setInterval(loadPlanes,15000);
loadPlanes();

// ===== –û–ü–ê–°–ù–´–ï –ó–û–ù–´ =====
function addDangerZone(lat,lon,radius,color){

const phi=(90-lat)*(Math.PI/180);
const theta=(lon+180)*(Math.PI/180);

const x=-Math.sin(phi)*Math.cos(theta);
const y=Math.cos(phi);
const z=Math.sin(phi)*Math.sin(theta);

const zone=new THREE.Mesh(
new THREE.SphereGeometry(radius,32,32),
new THREE.MeshBasicMaterial({
color,
transparent:true,
opacity:0.25
})
);

zone.position.set(x*1.01,y*1.01,z*1.01);
earth.add(zone);
}

// üî¥ –í–û–ô–ù–ê
addDangerZone(48.5,31,0.25,0xff0000); // –£–∫—Ä–∞–∏–Ω–∞
addDangerZone(33,44,0.2,0xff0000);   // –ò—Ä–∞–∫
addDangerZone(31,35,0.15,0xff0000);  // –ò–∑—Ä–∞–∏–ª—å

// üü† –®–¢–û–†–ú–´
addDangerZone(15,-60,0.3,0xff8800); // –ê—Ç–ª–∞–Ω—Ç–∏–∫–∞
addDangerZone(10,120,0.3,0xff8800); // –§–∏–ª–∏–ø–ø–∏–Ω—ã
addDangerZone(-15,160,0.25,0xff8800); // –¢–∏—Ö–∏–π –æ–∫–µ–∞–Ω

// ===== –í–†–ê–©–ï–ù–ò–ï =====
function animate(){
requestAnimationFrame(animate);

earth.rotation.y+=0.0015;
clouds.rotation.y+=0.002;
night.rotation.y+=0.0015;

renderer.render(scene,camera);
}
animate();

// ===== RESIZE =====
window.addEventListener("resize",()=>{
camera.aspect=window.innerWidth/window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>

</body>
</html>
